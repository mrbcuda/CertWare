<?xml version="1.0" encoding="UTF-8"?>
<auditRuleSets>
	<auditRuleSet 
		name="Effective Java"
		description="Audits from the book 'Effective Java' by Joshua Bloch. These best practices from the book cover areas like coding style, exception usage, Javadoc conventions, naming, possible errors, and threading."
		locked="true"
		active="true">
			
		#Thu Jul 15 16:56:41 PDT 2004
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.favorStaticMemberClassesOverNonStatic.enabled=true
		com.instantiations.assist.eclipse.audit.packageNamingConvention.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.avoidFinalizers.avoidFinalizers.comment=To quote from Effective Java\:\r\n\r\n"Finalizers are unpredictable, often dangerous, and generally unnecessary. Their use can cause erratic behavior, poor performance, and portability problems. Finalizers have a few valid uses, ... but as a rule of thumb, finalizers should be avoided."
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.overrideCloneJudiciously.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.minimizeScopeOfLocalVariables.comment=Minimizing the scope of local variables helps reduce errors caused by mis-using variables, according to Effective Java. Variables should not be defined before they are needed, and they should be defined in the innermost block possible.\r\n\r\nBecause of this the for-loop for iteration is preferred to the while-loop.\r\n\r\n\tfor (Iterator iter \= list.iterator(); iter.hasNext();) {\r\n\t\tObject element \= iter.next();\r\n\t\t...\r\n\t}
		com.instantiations.assist.eclipse.audit.returnValue.comment=When the method definition implies the return value will be a collection of some sort it is best to return a zero-legth instance of the collection rather than null. Effective Java addresses array-typed methods, but the principle could also apply to collections.
		com.instantiations.assist.eclipse.audit.classNamingConvention.namingConvention=;1;15;
		com.instantiations.assist.eclipse.audit.overloadedMethods.comment=Overloaded methods should be used with care. As Effective Java says "selection among overloaded methods is static, while selection among overriden methods is dynamic." In other words, selection of the method to invoke at runtime depends only on the class of the object, not on the classes of the arguments to the method.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.constructorsOnlyInvokeFinalMethods.comment=Effective Java warns that "constructors must not invoke overridable methods, directly or indirectly." This rule catches the direct invocations.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.useInterfacesOnlyToDefineTypes.comment=While interfaces can be used as a convenient mechanism to give a class access to a group of constants, that practice is to be avoided. According to Effective Java\: The constant interface pattern is a poor use of interfaces.
		com.instantiations.assist.eclipse.audit.unnecessaryExceptions.comment=See the item "avoid unnecessary use of checked exceptions" in Effective Java for a good discussion of the trade-offs in API design that revolve around checked exceptions.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.favorStaticMemberClassesOverNonStatic.comment=Static member classes do not require access to an enclosing instance. This makes them more flexible than non-static member classes, which can only be instantiatied in the context of an enclosing instance.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.alwaysOverridetoString.alwaysOverrideToString.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.avoidSubtypingCloneable.enabled=true
		com.instantiations.assist.eclipse.audit.booleanMethodNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.reusableImmutables.enabled=true
		com.instantiations.assist.eclipse.audit.disallowThreadGroupUsage.enabled=true
		com.instantiations.assist.eclipse.audit.consistentSuffixUsage.enabled=true
		com.instantiations.assist.eclipse.audit.methodNamingConvention.namingConvention=;2;15;
		com.instantiations.assist.eclipse.audit.methodNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.stringConcatenationInLoop.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.overrideCloneJudiciously.comment=If you must use clone then you should use it responsibly, and this rule can help. The general contract of clone is not fully specified. Effective Java says clone methods function as another kind of constructor, however they do not work well with final fields.
		com.instantiations.assist.eclipse.audit.overridingEqualsAndHashCode.enabled=true
		com.instantiations.assist.eclipse.audit.packagePrefixNamingConvention.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.avoidSubtypingCloneable.comment=The Cloneable interface implements an extra-linguistic device that did not live up to expectations, according to Effective Java. There are better ways to copy objects than by using the clone method.
		com.instantiations.assist.eclipse.audit.questionableName.questionableNames=bar/baz/foo/
		com.instantiations.assist.eclipse.audit.waitInsideWhile.enabled=true
		com.instantiations.assist.eclipse.audit.questionableName.enabled=true
		com.instantiations.assist.eclipse.audit.nonPrivateConstructorInStaticType.enabled=true
		com.instantiations.assist.eclipse.audit.questionableName.acceptableNames=b/c/d/e/ex/f/i/in/j/k/l/o/out/s/v/x/y/z/
		com.instantiations.assist.eclipse.audit.emptyCatchClause.enabled=true
		com.instantiations.assist.eclipse.audit.largeNumberOfParameters.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.alwaysOverridetoString.alwaysOverrideToString.comment=Effective Java makes three important points about the toString method.\r\n\r\n1. Providing a good toString implementation makes your class much more pleasant to use.\r\n\r\n2. The toString method should return all the interesting information contained in the object.\r\n\r\n3. The object should provide programmatic access to all the information presented by toString.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.minimizeScopeOfLocalVariables.detectVariablesWithoutInitializers=true
		com.instantiations.assist.eclipse.audit.reusableImmutables.comment=This rule works with String Created from Literal and Temporary Object Creation to implement the item Effective Java calls "avoid creating duplicate objects".
		com.instantiations.assist.eclipse.audit.classNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.disallowThreadGroupUsage.comment=According to Effective Java "thread groups are largely obsolete."
		com.instantiations.assist.eclipse.audit.temporaryObjectCreation.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.obeyEqualsContract.obeyGeneralContractOfEquals.enabled=true
		com.instantiations.assist.eclipse.audit.localVariableNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.constantNamingConvention.namingConvention=;1;9;
		com.instantiations.assist.eclipse.audit.interfaceNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.disallowNativeMethods.enabled=true
		com.instantiations.assist.eclipse.audit.methodNamingConvention.comment=This rule implements a portion of "design method signatures carefully" as described in Effective Java.
		com.instantiations.assist.eclipse.audit.stringConcatenationInLoop.comment=According to Effective Java "using the string concatenation operator repeatedly to concatenate N strings requires time quadratic in N." That's bad, especially in loops.
		com.instantiations.assist.eclipse.audit.unnecessaryExceptions.ignoreOverriddenExceptions=true
		com.instantiations.assist.eclipse.audit.labelNamingConvention.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.preferInterfacesToAbstractClasses.enabled=true
		com.instantiations.assist.eclipse.audit.emptyCatchClause.comment=Effective Java makes this point\: An empty catch block defeats the purpose of exceptions. At the very least, the catch block should contain a comment explaining why it is appropriate to ignore the exception.
		com.instantiations.assist.eclipse.audit.overridingEqualsAndHashCode.comment=Equal objects must have equal hash codes. A common mistake is to omit a definition of hashCode() in a class that overrides equals(). It can lead to bugs that are VERY difficult to find. See Effective Java for an excellent description of how to create good hashCode methods.
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.enforceTheSingletonPropertyWithAPrivateConstructor.enabled=true
		com.instantiations.assist.eclipse.audit.disallowSleepInsideWhile.enabled=true
		com.instantiations.assist.eclipse.audit.waitInsideWhile.comment=From Effective Java, this is the standard idiom for using the wait method\:\r\n\r\n\tsynchronized (obj) {\r\n\t\twhile (&lt;condition does not hold&gt;)\r\n\t\t\tobj.wait();\r\n\r\n\t\t... // perform action appropriate to condition\r\n\t}
		com.instantiations.assist.eclipse.audit.temporaryObjectCreation.comment=This rule works with Reusable Immutables and String Created from Literal to implement the item Effective Java calls "avoid creating duplicate objects".
		com.instantiations.assist.eclipse.audit.stringCreatedFromLiteral.enabled=true
		com.instantiations.assist.eclipse.audit.declareAsInterface.enabled=true
		com.instantiations.assist.eclipse.audit.nonPrivateConstructorInStaticType.comment=This rule implements the item that Effective Java calls "enforce noninstantiability with a private constructor".
		com.instantiations.assist.eclipse.audit.typeJavadoc.enabled=true
		com.instantiations.assist.eclipse.audit.fieldJavadoc.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.preferInterfacesToReflection.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.allowCompareToToThrowExceptions.enabled=true
		com.instantiations.assist.eclipse.audit.largeNumberOfParameters.comment=This rule implements a portion of "design method signatures carefully" as described in Effective Java.
		com.instantiations.assist.eclipse.audit.methodJavadoc.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.obeyEqualsContract.obeyGeneralContractOfEquals.comment=This audit rules checks for compliance with the "recipe for a high-quality equals method" given in Effective Java. The steps in gives are\:\r\n\r\n1. Use \=\= to determine if the argument is a reference to this object.\r\n\r\n2. Use instanceof to check that the argument is of the proper type. The type can be the class that defines the equals() method, a subclass of it, or one of the interfaces it implements.\r\n\r\n3. Cast the argument to the proper type.\r\n\r\nOnce the argument has been cast to the proper type more specific attributes can be checked, as described in Effective Java. This rule only examines the more general steps outlined above.\r\n\r\nA sample method might look like this\:\r\n\r\n\tpublic boolean equals(Object arg) {\r\n\t\treturn this \=\= arg\r\n\t\t\t|| arg instanceof MyClass\r\n\t\t\t\t&amp;&amp; ((MyClass)arg).isEqualTo(this);\r\n\t}\r\n\r\nIn addition, this rule also flags methods that overload equals instead of overriding it.
		com.instantiations.assist.eclipse.audit.emptyCatchClause.allowsCommentOnly=true
		com.instantiations.assist.eclipse.audit.disallowNativeMethods.comment=Java performance has gotten so good that it is rarely advisable to write native methods for performance reasons, according to Effective Java.
		com.instantiations.assist.eclipse.audit.staticFieldNamingConvention.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.preferInterfacesToAbstractClasses.comment=When designing extensible types it is generally better to define the type as an interface and provide a skeletal implementation of the type in an abstract class. As Effective Java points out, interfaces allow the construction of nonhierarchical type frameworks.
		com.instantiations.assist.eclipse.audit.instanceFieldNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.constantNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.methodParameterNamingConvention.enabled=true
		com.instantiations.assist.eclipse.audit.disallowSleepInsideWhile.comment=A busy-wait loop relies on the thread scheduler, which is likely to exhibit non-portable performance characteristics. A better design is to suspend the thread by calling Object.wait(). Effective Java has an item devoted to this topic, "don't depend on the thread scheduler."
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.enforceTheSingletonPropertyWithAPrivateConstructor.comment=Using a private constructor ensures the class cannot be instantiated by another object. Effective Java describes two approaches to implementing singletons, both of which are supported by this rule. In addition, the singleton value may be computed by lazy initialization, which is also allowed by this rule.
		com.instantiations.assist.eclipse.audit.stringCreatedFromLiteral.comment=This rule works with Reusable Immutables and Temporary Object Creation to implement the item Effective Java calls "avoid creating duplicate objects".
		com.instantiations.assist.eclipse.audit.declareAsInterface.comment=This rule implements a portion of "design method signatures carefully" as described in Effective Java.
		com.instantiations.assist.eclipse.audit.returnValue.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.minimizeScopeOfLocalVariables.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.preferInterfacesToReflection.comment=Use this rule as an aid to code review. It identifies reflective invocation of methods and constructors, and reflective field access. According to Effective Java these operations are usually more effective when done via an interface than reflection.
		com.instantiations.assist.eclipse.audit.overloadedMethods.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.useInterfacesOnlyToDefineTypes.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.constructorsOnlyInvokeFinalMethods.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.allowCompareToToThrowExceptions.severity=0
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.avoidFinalizers.avoidFinalizers.enabled=true
		com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.allowCompareToToThrowExceptions.comment=See the item in Effective Java titled "Consider implementing Comparable" for a full discussion of the do's and don'ts  of the compareTo method.
		com.instantiations.assist.eclipse.audit.unnecessaryExceptions.enabled=true
	</auditRuleSet>
</auditRuleSets>
