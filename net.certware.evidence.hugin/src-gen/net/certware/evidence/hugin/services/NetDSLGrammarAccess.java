/*
* generated by Xtext
*/

package net.certware.evidence.hugin.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class NetDSLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cDomainAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDomainDomainDefinitionParserRuleCall_0 = (RuleCall)cDomainAssignment.eContents().get(0);
		
		//Model:
		//	domain=DomainDefinition?;
		public ParserRule getRule() { return rule; }

		//domain=DomainDefinition?
		public Assignment getDomainAssignment() { return cDomainAssignment; }

		//DomainDefinition
		public RuleCall getDomainDomainDefinitionParserRuleCall_0() { return cDomainDomainDefinitionParserRuleCall_0; }
	}

	public class SignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Sign returns ecore::EString hidden():
		//	"+" | "-";
		public ParserRule getRule() { return rule; }

		//"+" | "-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+"
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class FloatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Float");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//Float returns ecore::EString:
		//	Sign? INT ("." INT)?;
		public ParserRule getRule() { return rule; }

		//Sign? INT ("." INT)?
		public Group getGroup() { return cGroup; }

		//Sign?
		public RuleCall getSignParserRuleCall_0() { return cSignParserRuleCall_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }

		//("." INT)?
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}

	public class DomainDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderDomainHeaderParserRuleCall_0_0 = (RuleCall)cHeaderAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsDomainElementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//DomainDefinition:
		//	header=DomainHeader elements+=DomainElement*;
		public ParserRule getRule() { return rule; }

		//header=DomainHeader elements+=DomainElement*
		public Group getGroup() { return cGroup; }

		//header=DomainHeader
		public Assignment getHeaderAssignment_0() { return cHeaderAssignment_0; }

		//DomainHeader
		public RuleCall getHeaderDomainHeaderParserRuleCall_0_0() { return cHeaderDomainHeaderParserRuleCall_0_0; }

		//elements+=DomainElement*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//DomainElement
		public RuleCall getElementsDomainElementParserRuleCall_1_0() { return cElementsDomainElementParserRuleCall_1_0; }
	}

	public class DomainHeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainHeader");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainHeaderAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//DomainHeader:
		//	{DomainHeader} "net" "{" attributes+=Attribute* "}";
		public ParserRule getRule() { return rule; }

		//{DomainHeader} "net" "{" attributes+=Attribute* "}"
		public Group getGroup() { return cGroup; }

		//{DomainHeader}
		public Action getDomainHeaderAction_0() { return cDomainHeaderAction_0; }

		//"net"
		public Keyword getNetKeyword_1() { return cNetKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class DomainElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPotentialParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClassDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//DomainElement:
		//	BasicNode | Potential | ClassDefinition;
		public ParserRule getRule() { return rule; }

		//BasicNode | Potential | ClassDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicNode
		public RuleCall getBasicNodeParserRuleCall_0() { return cBasicNodeParserRuleCall_0; }

		//Potential
		public RuleCall getPotentialParserRuleCall_1() { return cPotentialParserRuleCall_1; }

		//ClassDefinition
		public RuleCall getClassDefinitionParserRuleCall_2() { return cClassDefinitionParserRuleCall_2; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStatesAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLabelAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPositionAttributeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSubtypeAttributeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStateValuesAttributeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cApplicationAttributeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNodeSizeAttributeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Attribute:
		//	StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute
		//	| NodeSizeAttribute;
		public ParserRule getRule() { return rule; }

		//StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute |
		//NodeSizeAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//StatesAttribute
		public RuleCall getStatesAttributeParserRuleCall_0() { return cStatesAttributeParserRuleCall_0; }

		//LabelAttribute
		public RuleCall getLabelAttributeParserRuleCall_1() { return cLabelAttributeParserRuleCall_1; }

		//PositionAttribute
		public RuleCall getPositionAttributeParserRuleCall_2() { return cPositionAttributeParserRuleCall_2; }

		//SubtypeAttribute
		public RuleCall getSubtypeAttributeParserRuleCall_3() { return cSubtypeAttributeParserRuleCall_3; }

		//StateValuesAttribute
		public RuleCall getStateValuesAttributeParserRuleCall_4() { return cStateValuesAttributeParserRuleCall_4; }

		//ApplicationAttribute
		public RuleCall getApplicationAttributeParserRuleCall_5() { return cApplicationAttributeParserRuleCall_5; }

		//NodeSizeAttribute
		public RuleCall getNodeSizeAttributeParserRuleCall_6() { return cNodeSizeAttributeParserRuleCall_6; }
	}

	public class BasicNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeywordAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeywordBasicNodeKeywordParserRuleCall_0_0 = (RuleCall)cKeywordAssignment_0.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BasicNode:
		//	keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}";
		public ParserRule getRule() { return rule; }

		//keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}"
		public Group getGroup() { return cGroup; }

		//keyword=BasicNodeKeyword
		public Assignment getKeywordAssignment_0() { return cKeywordAssignment_0; }

		//BasicNodeKeyword
		public RuleCall getKeywordBasicNodeKeywordParserRuleCall_0_0() { return cKeywordBasicNodeKeywordParserRuleCall_0_0; }

		//id=ID?
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_1_0() { return cIdIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class BasicNodeKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicNodeKeyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cDiscreteKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cContinuousKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Keyword cNodeKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cDecisionKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUtilityKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cFunctionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//BasicNodeKeyword returns ecore::EString:
		//	("discrete" | "continuous")? "node" | "decision" | "utility" | "function";
		public ParserRule getRule() { return rule; }

		//("discrete" | "continuous")? "node" | "decision" | "utility" | "function"
		public Alternatives getAlternatives() { return cAlternatives; }

		//("discrete" | "continuous")? "node"
		public Group getGroup_0() { return cGroup_0; }

		//("discrete" | "continuous")?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"discrete"
		public Keyword getDiscreteKeyword_0_0_0() { return cDiscreteKeyword_0_0_0; }

		//"continuous"
		public Keyword getContinuousKeyword_0_0_1() { return cContinuousKeyword_0_0_1; }

		//"node"
		public Keyword getNodeKeyword_0_1() { return cNodeKeyword_0_1; }

		//"decision"
		public Keyword getDecisionKeyword_1() { return cDecisionKeyword_1; }

		//"utility"
		public Keyword getUtilityKeyword_2() { return cUtilityKeyword_2; }

		//"function"
		public Keyword getFunctionKeyword_3() { return cFunctionKeyword_3; }
	}

	public class StatesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatesAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStatesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatesSTRINGTerminalRuleCall_4_0 = (RuleCall)cStatesAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//StatesAttribute:
		//	{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";";
		public ParserRule getRule() { return rule; }

		//{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";"
		public Group getGroup() { return cGroup; }

		//{StatesAttribute}
		public Action getStatesAttributeAction_0() { return cStatesAttributeAction_0; }

		//"states"
		public Keyword getStatesKeyword_1() { return cStatesKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//states+=STRING*
		public Assignment getStatesAssignment_4() { return cStatesAssignment_4; }

		//STRING
		public RuleCall getStatesSTRINGTerminalRuleCall_4_0() { return cStatesSTRINGTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class LabelAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabelAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLabelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LabelAttribute:
		//	"label" "=" value=STRING ";";
		public ParserRule getRule() { return rule; }

		//"label" "=" value=STRING ";"
		public Group getGroup() { return cGroup; }

		//"label"
		public Keyword getLabelKeyword_0() { return cLabelKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=STRING
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_0() { return cValueSTRINGTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class PositionAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PositionAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPositionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cXAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cXINTTerminalRuleCall_3_0 = (RuleCall)cXAssignment_3.eContents().get(0);
		private final Assignment cYAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cYINTTerminalRuleCall_4_0 = (RuleCall)cYAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PositionAttribute:
		//	"position" "=" "(" x=INT y=INT ")" ";";
		public ParserRule getRule() { return rule; }

		//"position" "=" "(" x=INT y=INT ")" ";"
		public Group getGroup() { return cGroup; }

		//"position"
		public Keyword getPositionKeyword_0() { return cPositionKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//x=INT
		public Assignment getXAssignment_3() { return cXAssignment_3; }

		//INT
		public RuleCall getXINTTerminalRuleCall_3_0() { return cXINTTerminalRuleCall_3_0; }

		//y=INT
		public Assignment getYAssignment_4() { return cYAssignment_4; }

		//INT
		public RuleCall getYINTTerminalRuleCall_4_0() { return cYINTTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SubtypeAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtypeAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubtypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSubtypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cSubtypeAlternatives_2_0 = (Alternatives)cSubtypeAssignment_2.eContents().get(0);
		private final Keyword cSubtypeLabelKeyword_2_0_0 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(0);
		private final Keyword cSubtypeBooleanKeyword_2_0_1 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(1);
		private final Keyword cSubtypeNumberKeyword_2_0_2 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(2);
		private final Keyword cSubtypeIntervalKeyword_2_0_3 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(3);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SubtypeAttribute:
		//	"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";";
		public ParserRule getRule() { return rule; }

		//"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";"
		public Group getGroup() { return cGroup; }

		//"subtype"
		public Keyword getSubtypeKeyword_0() { return cSubtypeKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//subtype=("label" | "boolean" | "number" | "interval")
		public Assignment getSubtypeAssignment_2() { return cSubtypeAssignment_2; }

		//"label" | "boolean" | "number" | "interval"
		public Alternatives getSubtypeAlternatives_2_0() { return cSubtypeAlternatives_2_0; }

		//"label"
		public Keyword getSubtypeLabelKeyword_2_0_0() { return cSubtypeLabelKeyword_2_0_0; }

		//"boolean"
		public Keyword getSubtypeBooleanKeyword_2_0_1() { return cSubtypeBooleanKeyword_2_0_1; }

		//"number"
		public Keyword getSubtypeNumberKeyword_2_0_2() { return cSubtypeNumberKeyword_2_0_2; }

		//"interval"
		public Keyword getSubtypeIntervalKeyword_2_0_3() { return cSubtypeIntervalKeyword_2_0_3; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class StateValuesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateValuesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cState_valuesKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumbersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumbersINTTerminalRuleCall_3_0 = (RuleCall)cNumbersAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StateValuesAttribute:
		//	"state_values" "=" "(" numbers+=INT+ ")" ";";
		public ParserRule getRule() { return rule; }

		//"state_values" "=" "(" numbers+=INT+ ")" ";"
		public Group getGroup() { return cGroup; }

		//"state_values"
		public Keyword getState_valuesKeyword_0() { return cState_valuesKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//numbers+=INT+
		public Assignment getNumbersAssignment_3() { return cNumbersAssignment_3; }

		//INT
		public RuleCall getNumbersINTTerminalRuleCall_3_0() { return cNumbersINTTerminalRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ApplicationAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ApplicationAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyIDTerminalRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ApplicationAttribute:
		//	key=ID "=" value=STRING ";";
		public ParserRule getRule() { return rule; }

		//key=ID "=" value=STRING ";"
		public Group getGroup() { return cGroup; }

		//key=ID
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//ID
		public RuleCall getKeyIDTerminalRuleCall_0_0() { return cKeyIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=STRING
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_0() { return cValueSTRINGTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class NodeSizeAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeSizeAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNode_sizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cWidthAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWidthINTTerminalRuleCall_3_0 = (RuleCall)cWidthAssignment_3.eContents().get(0);
		private final Assignment cHeightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cHeightINTTerminalRuleCall_4_0 = (RuleCall)cHeightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// global magic for HUGIN GUI
		//NodeSizeAttribute:
		//	"node_size" "=" "(" width=INT height=INT ")" ";";
		public ParserRule getRule() { return rule; }

		//"node_size" "=" "(" width=INT height=INT ")" ";"
		public Group getGroup() { return cGroup; }

		//"node_size"
		public Keyword getNode_sizeKeyword_0() { return cNode_sizeKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//width=INT
		public Assignment getWidthAssignment_3() { return cWidthAssignment_3; }

		//INT
		public RuleCall getWidthINTTerminalRuleCall_3_0() { return cWidthINTTerminalRuleCall_3_0; }

		//height=INT
		public Assignment getHeightAssignment_4() { return cHeightAssignment_4; }

		//INT
		public RuleCall getHeightINTTerminalRuleCall_4_0() { return cHeightINTTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class PotentialElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Potential");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPotentialKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGraphAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGraphPotentialGraphParserRuleCall_1_0 = (RuleCall)cGraphAssignment_1.eContents().get(0);
		private final Assignment cModelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cModelPotentialModelParserRuleCall_2_0 = (RuleCall)cModelAssignment_2.eContents().get(0);
		
		//Potential:
		//	"potential" graph=PotentialGraph model=PotentialModel;
		public ParserRule getRule() { return rule; }

		//"potential" graph=PotentialGraph model=PotentialModel
		public Group getGroup() { return cGroup; }

		//"potential"
		public Keyword getPotentialKeyword_0() { return cPotentialKeyword_0; }

		//graph=PotentialGraph
		public Assignment getGraphAssignment_1() { return cGraphAssignment_1; }

		//PotentialGraph
		public RuleCall getGraphPotentialGraphParserRuleCall_1_0() { return cGraphPotentialGraphParserRuleCall_1_0; }

		//model=PotentialModel
		public Assignment getModelAssignment_2() { return cModelAssignment_2; }

		//PotentialModel
		public RuleCall getModelPotentialModelParserRuleCall_2_0() { return cModelPotentialModelParserRuleCall_2_0; }
	}

	public class PotentialGraphElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialGraph");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialGraphAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenIDTerminalRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cVerticalLineKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParentsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParentsIDTerminalRuleCall_3_1_0 = (RuleCall)cParentsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PotentialGraph:
		//	{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")";
		public ParserRule getRule() { return rule; }

		//{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")"
		public Group getGroup() { return cGroup; }

		//{PotentialGraph}
		public Action getPotentialGraphAction_0() { return cPotentialGraphAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//children+=ID*
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//ID
		public RuleCall getChildrenIDTerminalRuleCall_2_0() { return cChildrenIDTerminalRuleCall_2_0; }

		//("|" parents+=ID*)?
		public Group getGroup_3() { return cGroup_3; }

		//"|"
		public Keyword getVerticalLineKeyword_3_0() { return cVerticalLineKeyword_3_0; }

		//parents+=ID*
		public Assignment getParentsAssignment_3_1() { return cParentsAssignment_3_1; }

		//ID
		public RuleCall getParentsIDTerminalRuleCall_3_1_0() { return cParentsIDTerminalRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class PotentialModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributesPotentialAttributeParserRuleCall_2_0 = (RuleCall)cAttributesAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PotentialModel:
		//	{PotentialModel} "{" attributes+=PotentialAttribute* "}";
		public ParserRule getRule() { return rule; }

		//{PotentialModel} "{" attributes+=PotentialAttribute* "}"
		public Group getGroup() { return cGroup; }

		//{PotentialModel}
		public Action getPotentialModelAction_0() { return cPotentialModelAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//attributes+=PotentialAttribute*
		public Assignment getAttributesAssignment_2() { return cAttributesAssignment_2; }

		//PotentialAttribute
		public RuleCall getAttributesPotentialAttributeParserRuleCall_2_0() { return cAttributesPotentialAttributeParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PotentialAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialAttribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPotentialDataAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPotentialTableAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PotentialAttribute:
		//	PotentialDataAttribute | PotentialTableAttribute;
		public ParserRule getRule() { return rule; }

		//PotentialDataAttribute | PotentialTableAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//PotentialDataAttribute
		public RuleCall getPotentialDataAttributeParserRuleCall_0() { return cPotentialDataAttributeParserRuleCall_0; }

		//PotentialTableAttribute
		public RuleCall getPotentialTableAttributeParserRuleCall_1() { return cPotentialTableAttributeParserRuleCall_1; }
	}

	public class PotentialDataAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialDataAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialDataAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDataKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cUnstructuredAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cUnstructuredUnstructuredDataListParserRuleCall_4_0_0 = (RuleCall)cUnstructuredAssignment_4_0.eContents().get(0);
		private final Assignment cItemsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cItemsStructuredDataListParserRuleCall_4_1_0 = (RuleCall)cItemsAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PotentialDataAttribute:
		//	{PotentialDataAttribute} "data" "=" "(" (unstructured=UnstructuredDataList | items+=StructuredDataList*) ")" ";";
		public ParserRule getRule() { return rule; }

		//{PotentialDataAttribute} "data" "=" "(" (unstructured=UnstructuredDataList | items+=StructuredDataList*) ")" ";"
		public Group getGroup() { return cGroup; }

		//{PotentialDataAttribute}
		public Action getPotentialDataAttributeAction_0() { return cPotentialDataAttributeAction_0; }

		//"data"
		public Keyword getDataKeyword_1() { return cDataKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//unstructured=UnstructuredDataList | items+=StructuredDataList*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//unstructured=UnstructuredDataList
		public Assignment getUnstructuredAssignment_4_0() { return cUnstructuredAssignment_4_0; }

		//UnstructuredDataList
		public RuleCall getUnstructuredUnstructuredDataListParserRuleCall_4_0_0() { return cUnstructuredUnstructuredDataListParserRuleCall_4_0_0; }

		//items+=StructuredDataList*
		public Assignment getItemsAssignment_4_1() { return cItemsAssignment_4_1; }

		//StructuredDataList
		public RuleCall getItemsStructuredDataListParserRuleCall_4_1_0() { return cItemsStructuredDataListParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class UnstructuredDataListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnstructuredDataList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnstructuredDataListAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cListAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cListFloatDataListParserRuleCall_0_1_0 = (RuleCall)cListAssignment_0_1.eContents().get(0);
		private final Assignment cNormalAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNormalNormalDistributionParserRuleCall_1_0 = (RuleCall)cNormalAssignment_1.eContents().get(0);
		
		//UnstructuredDataList:
		//	{UnstructuredDataList} list=FloatDataList | normal=NormalDistribution;
		public ParserRule getRule() { return rule; }

		//{UnstructuredDataList} list=FloatDataList | normal=NormalDistribution
		public Alternatives getAlternatives() { return cAlternatives; }

		//{UnstructuredDataList} list=FloatDataList
		public Group getGroup_0() { return cGroup_0; }

		//{UnstructuredDataList}
		public Action getUnstructuredDataListAction_0_0() { return cUnstructuredDataListAction_0_0; }

		//list=FloatDataList
		public Assignment getListAssignment_0_1() { return cListAssignment_0_1; }

		//FloatDataList
		public RuleCall getListFloatDataListParserRuleCall_0_1_0() { return cListFloatDataListParserRuleCall_0_1_0; }

		//normal=NormalDistribution
		public Assignment getNormalAssignment_1() { return cNormalAssignment_1; }

		//NormalDistribution
		public RuleCall getNormalNormalDistributionParserRuleCall_1_0() { return cNormalNormalDistributionParserRuleCall_1_0; }
	}

	public class StructuredDataListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructuredDataList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStructuredDataListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cListAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cListFloatDataListParserRuleCall_2_0_0 = (RuleCall)cListAssignment_2_0.eContents().get(0);
		private final Assignment cItemsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cItemsStructuredDataListParserRuleCall_2_1_0 = (RuleCall)cItemsAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//StructuredDataList:
		//	{StructuredDataList} "(" (list=FloatDataList | items+=StructuredDataList*) ")";
		public ParserRule getRule() { return rule; }

		//{StructuredDataList} "(" (list=FloatDataList | items+=StructuredDataList*) ")"
		public Group getGroup() { return cGroup; }

		//{StructuredDataList}
		public Action getStructuredDataListAction_0() { return cStructuredDataListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//list=FloatDataList | items+=StructuredDataList*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//list=FloatDataList
		public Assignment getListAssignment_2_0() { return cListAssignment_2_0; }

		//FloatDataList
		public RuleCall getListFloatDataListParserRuleCall_2_0_0() { return cListFloatDataListParserRuleCall_2_0_0; }

		//items+=StructuredDataList*
		public Assignment getItemsAssignment_2_1() { return cItemsAssignment_2_1; }

		//StructuredDataList
		public RuleCall getItemsStructuredDataListParserRuleCall_2_1_0() { return cItemsStructuredDataListParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FloatDataListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FloatDataList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFloatDataListAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cItemsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cItemsFloatParserRuleCall_1_0 = (RuleCall)cItemsAssignment_1.eContents().get(0);
		
		//FloatDataList:
		//	{FloatDataList} items+=Float*;
		public ParserRule getRule() { return rule; }

		//{FloatDataList} items+=Float*
		public Group getGroup() { return cGroup; }

		//{FloatDataList}
		public Action getFloatDataListAction_0() { return cFloatDataListAction_0; }

		//items+=Float*
		public Assignment getItemsAssignment_1() { return cItemsAssignment_1; }

		//Float
		public RuleCall getItemsFloatParserRuleCall_1_0() { return cItemsFloatParserRuleCall_1_0; }
	}

	public class NormalDistributionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NormalDistribution");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNormalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMeanAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMeanMeanExpressionParserRuleCall_2_0 = (RuleCall)cMeanAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarianceAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarianceFloatParserRuleCall_4_0 = (RuleCall)cVarianceAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//NormalDistribution:
		//	"normal" "(" mean=MeanExpression "," variance=Float ")";
		public ParserRule getRule() { return rule; }

		//"normal" "(" mean=MeanExpression "," variance=Float ")"
		public Group getGroup() { return cGroup; }

		//"normal"
		public Keyword getNormalKeyword_0() { return cNormalKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//mean=MeanExpression
		public Assignment getMeanAssignment_2() { return cMeanAssignment_2; }

		//MeanExpression
		public RuleCall getMeanMeanExpressionParserRuleCall_2_0() { return cMeanMeanExpressionParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//variance=Float
		public Assignment getVarianceAssignment_4() { return cVarianceAssignment_4; }

		//Float
		public RuleCall getVarianceFloatParserRuleCall_4_0() { return cVarianceFloatParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class MeanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MeanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMeanTermParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cMeanTermParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//MeanExpression returns ecore::EString:
		//	MeanTerm ("+" MeanTerm)*;
		public ParserRule getRule() { return rule; }

		//MeanTerm ("+" MeanTerm)*
		public Group getGroup() { return cGroup; }

		//MeanTerm
		public RuleCall getMeanTermParserRuleCall_0() { return cMeanTermParserRuleCall_0; }

		//("+" MeanTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//MeanTerm
		public RuleCall getMeanTermParserRuleCall_1_1() { return cMeanTermParserRuleCall_1_1; }
	}

	public class MeanTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MeanTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFloatParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cFloatParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//MeanTerm returns ecore::EString:
		//	Float | Float "*" ID | ID;
		public ParserRule getRule() { return rule; }

		//Float | Float "*" ID | ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//Float
		public RuleCall getFloatParserRuleCall_0() { return cFloatParserRuleCall_0; }

		//Float "*" ID
		public Group getGroup_1() { return cGroup_1; }

		//Float
		public RuleCall getFloatParserRuleCall_1_0() { return cFloatParserRuleCall_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }

		//ID
		public RuleCall getIDTerminalRuleCall_2() { return cIDTerminalRuleCall_2; }
	}

	public class PotentialTableAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialTableAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodesModelNodesAttributeParserRuleCall_0_0 = (RuleCall)cNodesAssignment_0.eContents().get(0);
		private final Assignment cSamplesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSamplesSamplesAttributeParserRuleCall_1_0 = (RuleCall)cSamplesAssignment_1.eContents().get(0);
		private final Assignment cDataAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDataModelDataAttributeParserRuleCall_2_0 = (RuleCall)cDataAssignment_2.eContents().get(0);
		
		//PotentialTableAttribute:
		//	nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute;
		public ParserRule getRule() { return rule; }

		//nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute
		public Group getGroup() { return cGroup; }

		//nodes=ModelNodesAttribute
		public Assignment getNodesAssignment_0() { return cNodesAssignment_0; }

		//ModelNodesAttribute
		public RuleCall getNodesModelNodesAttributeParserRuleCall_0_0() { return cNodesModelNodesAttributeParserRuleCall_0_0; }

		//samples=SamplesAttribute?
		public Assignment getSamplesAssignment_1() { return cSamplesAssignment_1; }

		//SamplesAttribute
		public RuleCall getSamplesSamplesAttributeParserRuleCall_1_0() { return cSamplesSamplesAttributeParserRuleCall_1_0; }

		//data=ModelDataAttribute
		public Assignment getDataAssignment_2() { return cDataAssignment_2; }

		//ModelDataAttribute
		public RuleCall getDataModelDataAttributeParserRuleCall_2_0() { return cDataModelDataAttributeParserRuleCall_2_0; }
	}

	public class ModelNodesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelNodesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelNodesAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModel_nodesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConfigurationsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConfigurationsIDTerminalRuleCall_4_0 = (RuleCall)cConfigurationsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ModelNodesAttribute:
		//	{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";";
		public ParserRule getRule() { return rule; }

		//{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";"
		public Group getGroup() { return cGroup; }

		//{ModelNodesAttribute}
		public Action getModelNodesAttributeAction_0() { return cModelNodesAttributeAction_0; }

		//"model_nodes"
		public Keyword getModel_nodesKeyword_1() { return cModel_nodesKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//configurations+=ID*
		public Assignment getConfigurationsAssignment_4() { return cConfigurationsAssignment_4; }

		//ID
		public RuleCall getConfigurationsIDTerminalRuleCall_4_0() { return cConfigurationsIDTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SamplesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SamplesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSamples_per_intervalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueINTTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SamplesAttribute:
		//	"samples_per_interval" "=" value=INT ";";
		public ParserRule getRule() { return rule; }

		//"samples_per_interval" "=" value=INT ";"
		public Group getGroup() { return cGroup; }

		//"samples_per_interval"
		public Keyword getSamples_per_intervalKeyword_0() { return cSamples_per_intervalKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=INT
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_0() { return cValueINTTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ModelDataAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelDataAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelDataAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModel_dataKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ModelDataAttribute:
		//	{ModelDataAttribute} "model_data" "=" "(" ")" // TODO add expression sequence, introduces left recursion
		//	";";
		public ParserRule getRule() { return rule; }

		//{ModelDataAttribute} "model_data" "=" "(" ")" // TODO add expression sequence, introduces left recursion
		//";"
		public Group getGroup() { return cGroup; }

		//{ModelDataAttribute}
		public Action getModelDataAttributeAction_0() { return cModelDataAttributeAction_0; }

		//"model_data"
		public Keyword getModel_dataKeyword_1() { return cModel_dataKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//// TODO add expression sequence, introduces left recursion
		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ClassDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsClassElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/////////////////////////////////////////////////////
		//// classes
		/////////////////////////////////////////////////////
		//ClassDefinition:
		//	"class" name=ID "{" elements+=ClassElement* "}";
		public ParserRule getRule() { return rule; }

		//"class" name=ID "{" elements+=ClassElement* "}"
		public Group getGroup() { return cGroup; }

		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//elements+=ClassElement*
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }

		//ClassElement
		public RuleCall getElementsClassElementParserRuleCall_3_0() { return cElementsClassElementParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ClassElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDomainElementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClassInstanceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ClassElement:
		//	DomainElement | Attribute | ClassInstance;
		public ParserRule getRule() { return rule; }

		//DomainElement | Attribute | ClassInstance
		public Alternatives getAlternatives() { return cAlternatives; }

		//DomainElement
		public RuleCall getDomainElementParserRuleCall_0() { return cDomainElementParserRuleCall_0; }

		//Attribute
		public RuleCall getAttributeParserRuleCall_1() { return cAttributeParserRuleCall_1; }

		//ClassInstance
		public RuleCall getClassInstanceParserRuleCall_2() { return cClassInstanceParserRuleCall_2; }
	}

	public class ClassInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInstanceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInstanceNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstanceNameIDTerminalRuleCall_1_0 = (RuleCall)cInstanceNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClassNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cClassNameIDTerminalRuleCall_3_0 = (RuleCall)cClassNameAssignment_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cInputAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cInputInputBindingsParserRuleCall_5_0 = (RuleCall)cInputAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cOutputAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cOutputOutputBindingsParserRuleCall_6_1_0 = (RuleCall)cOutputAssignment_6_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cLeftCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cAttributesAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cAttributesNodeAttributesParserRuleCall_9_0 = (RuleCall)cAttributesAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//ClassInstance:
		//	"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
		//	attributes=NodeAttributes "}";
		public ParserRule getRule() { return rule; }

		//"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
		//attributes=NodeAttributes "}"
		public Group getGroup() { return cGroup; }

		//"instance"
		public Keyword getInstanceKeyword_0() { return cInstanceKeyword_0; }

		//instanceName=ID
		public Assignment getInstanceNameAssignment_1() { return cInstanceNameAssignment_1; }

		//ID
		public RuleCall getInstanceNameIDTerminalRuleCall_1_0() { return cInstanceNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//className=ID
		public Assignment getClassNameAssignment_3() { return cClassNameAssignment_3; }

		//ID
		public RuleCall getClassNameIDTerminalRuleCall_3_0() { return cClassNameIDTerminalRuleCall_3_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//input=InputBindings?
		public Assignment getInputAssignment_5() { return cInputAssignment_5; }

		//InputBindings
		public RuleCall getInputInputBindingsParserRuleCall_5_0() { return cInputInputBindingsParserRuleCall_5_0; }

		//(";" output=OutputBindings)?
		public Group getGroup_6() { return cGroup_6; }

		//";"
		public Keyword getSemicolonKeyword_6_0() { return cSemicolonKeyword_6_0; }

		//output=OutputBindings
		public Assignment getOutputAssignment_6_1() { return cOutputAssignment_6_1; }

		//OutputBindings
		public RuleCall getOutputOutputBindingsParserRuleCall_6_1_0() { return cOutputOutputBindingsParserRuleCall_6_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_8() { return cLeftCurlyBracketKeyword_8; }

		//attributes=NodeAttributes
		public Assignment getAttributesAssignment_9() { return cAttributesAssignment_9; }

		//NodeAttributes
		public RuleCall getAttributesNodeAttributesParserRuleCall_9_0() { return cAttributesNodeAttributesParserRuleCall_9_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}

	public class InputBindingsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputBindings");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsInputBindingParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsInputBindingsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//InputBindings:
		//	lhs=InputBinding "," rhs=InputBindings;
		public ParserRule getRule() { return rule; }

		//lhs=InputBinding "," rhs=InputBindings
		public Group getGroup() { return cGroup; }

		//lhs=InputBinding
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//InputBinding
		public RuleCall getLhsInputBindingParserRuleCall_0_0() { return cLhsInputBindingParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//rhs=InputBindings
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//InputBindings
		public RuleCall getRhsInputBindingsParserRuleCall_2_0() { return cRhsInputBindingsParserRuleCall_2_0; }
	}

	public class InputBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFormalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFormalIDTerminalRuleCall_0_0 = (RuleCall)cFormalAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActualAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActualIDTerminalRuleCall_2_0 = (RuleCall)cActualAssignment_2.eContents().get(0);
		
		//InputBinding:
		//	formal=ID "=" actual=ID;
		public ParserRule getRule() { return rule; }

		//formal=ID "=" actual=ID
		public Group getGroup() { return cGroup; }

		//formal=ID
		public Assignment getFormalAssignment_0() { return cFormalAssignment_0; }

		//ID
		public RuleCall getFormalIDTerminalRuleCall_0_0() { return cFormalIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//actual=ID
		public Assignment getActualAssignment_2() { return cActualAssignment_2; }

		//ID
		public RuleCall getActualIDTerminalRuleCall_2_0() { return cActualIDTerminalRuleCall_2_0; }
	}

	public class OutputBindingsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputBindings");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsOutputBindingParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsOutputBindingsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//OutputBindings:
		//	lhs=OutputBinding "," rhs=OutputBindings;
		public ParserRule getRule() { return rule; }

		//lhs=OutputBinding "," rhs=OutputBindings
		public Group getGroup() { return cGroup; }

		//lhs=OutputBinding
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//OutputBinding
		public RuleCall getLhsOutputBindingParserRuleCall_0_0() { return cLhsOutputBindingParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//rhs=OutputBindings
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//OutputBindings
		public RuleCall getRhsOutputBindingsParserRuleCall_2_0() { return cRhsOutputBindingsParserRuleCall_2_0; }
	}

	public class OutputBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActualAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActualIDTerminalRuleCall_0_0 = (RuleCall)cActualAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFormalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFormalIDTerminalRuleCall_2_0 = (RuleCall)cFormalAssignment_2.eContents().get(0);
		
		//OutputBinding:
		//	actual=ID "=" formal=ID;
		public ParserRule getRule() { return rule; }

		//actual=ID "=" formal=ID
		public Group getGroup() { return cGroup; }

		//actual=ID
		public Assignment getActualAssignment_0() { return cActualAssignment_0; }

		//ID
		public RuleCall getActualIDTerminalRuleCall_0_0() { return cActualIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//formal=ID
		public Assignment getFormalAssignment_2() { return cFormalAssignment_2; }

		//ID
		public RuleCall getFormalIDTerminalRuleCall_2_0() { return cFormalIDTerminalRuleCall_2_0; }
	}

	public class NodeAttributesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeAttributes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLabelAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPositionAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cApplicationAttributeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//NodeAttributes:
		//	LabelAttribute | PositionAttribute | ApplicationAttribute;
		public ParserRule getRule() { return rule; }

		//LabelAttribute | PositionAttribute | ApplicationAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//LabelAttribute
		public RuleCall getLabelAttributeParserRuleCall_0() { return cLabelAttributeParserRuleCall_0; }

		//PositionAttribute
		public RuleCall getPositionAttributeParserRuleCall_1() { return cPositionAttributeParserRuleCall_1; }

		//ApplicationAttribute
		public RuleCall getApplicationAttributeParserRuleCall_2() { return cApplicationAttributeParserRuleCall_2; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsSimpleExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsSimpleExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		/////////////////////////////////////////////////////
		//// expressions
		/////////////////////////////////////////////////////
		//// simple=SimpleExpression
		//Expression:
		//	lhs=SimpleExpression (Comparison rhs+=SimpleExpression)* // |
		//;
		public ParserRule getRule() { return rule; }

		//lhs=SimpleExpression (Comparison rhs+=SimpleExpression)* // |
		public Group getGroup() { return cGroup; }

		//lhs=SimpleExpression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//SimpleExpression
		public RuleCall getLhsSimpleExpressionParserRuleCall_0_0() { return cLhsSimpleExpressionParserRuleCall_0_0; }

		//(Comparison rhs+=SimpleExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_1_0() { return cComparisonParserRuleCall_1_0; }

		//rhs+=SimpleExpression
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }

		//SimpleExpression
		public RuleCall getRhsSimpleExpressionParserRuleCall_1_1_0() { return cRhsSimpleExpressionParserRuleCall_1_1_0; }
	}

	public class SimpleExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsSimpleExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		//// PlusOrMinus single=Term // |
		//// lhs=Term
		//SimpleExpression:
		//	lhs=Term (PlusOrMinus rhs+=SimpleExpression)* // | // was swapped
		//;
		public ParserRule getRule() { return rule; }

		//lhs=Term (PlusOrMinus rhs+=SimpleExpression)* // | // was swapped
		public Group getGroup() { return cGroup; }

		//lhs=Term
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Term
		public RuleCall getLhsTermParserRuleCall_0_0() { return cLhsTermParserRuleCall_0_0; }

		//(PlusOrMinus rhs+=SimpleExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_1_0() { return cPlusOrMinusParserRuleCall_1_0; }

		//rhs+=SimpleExpression
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }

		//SimpleExpression
		public RuleCall getRhsSimpleExpressionParserRuleCall_1_1_0() { return cRhsSimpleExpressionParserRuleCall_1_1_0; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsExpFactorParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cTimesOrDivideParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsTermParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		//// lhs=ExpFactor
		//Term:
		//	lhs=ExpFactor (TimesOrDivide rhs+=Term)* // |
		//;
		public ParserRule getRule() { return rule; }

		//lhs=ExpFactor (TimesOrDivide rhs+=Term)* // |
		public Group getGroup() { return cGroup; }

		//lhs=ExpFactor
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//ExpFactor
		public RuleCall getLhsExpFactorParserRuleCall_0_0() { return cLhsExpFactorParserRuleCall_0_0; }

		//(TimesOrDivide rhs+=Term)*
		public Group getGroup_1() { return cGroup_1; }

		//TimesOrDivide
		public RuleCall getTimesOrDivideParserRuleCall_1_0() { return cTimesOrDivideParserRuleCall_1_0; }

		//rhs+=Term
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }

		//Term
		public RuleCall getRhsTermParserRuleCall_1_1_0() { return cRhsTermParserRuleCall_1_1_0; }
	}

	public class ExpFactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpFactor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsFactorParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsExpFactorParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		//// factor=Factor
		//ExpFactor:
		//	lhs=Factor ("^" rhs+=ExpFactor)* // |
		//;
		public ParserRule getRule() { return rule; }

		//lhs=Factor ("^" rhs+=ExpFactor)* // |
		public Group getGroup() { return cGroup; }

		//lhs=Factor
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Factor
		public RuleCall getLhsFactorParserRuleCall_0_0() { return cLhsFactorParserRuleCall_0_0; }

		//("^" rhs+=ExpFactor)*
		public Group getGroup_1() { return cGroup_1; }

		//"^"
		public Keyword getCircumflexAccentKeyword_1_0() { return cCircumflexAccentKeyword_1_0; }

		//rhs+=ExpFactor
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }

		//ExpFactor
		public RuleCall getRhsExpFactorParserRuleCall_1_1_0() { return cRhsExpFactorParserRuleCall_1_1_0; }
	}

	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Factor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cFactorAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNumberAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNumberINTTerminalRuleCall_0_1_0 = (RuleCall)cNumberAssignment_0_1.eContents().get(0);
		private final Assignment cNodeNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNodeNameIDTerminalRuleCall_1_0 = (RuleCall)cNodeNameAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final Keyword cValueFalseKeyword_3_0 = (Keyword)cValueAssignment_3.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final Keyword cValueTrueKeyword_4_0 = (Keyword)cValueAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cExpressionAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_5_1_0 = (RuleCall)cExpressionAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cOpAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cOpOperatorNameParserRuleCall_6_0_0 = (RuleCall)cOpAssignment_6_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cSequenceAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cSequenceExpressionSequenceParserRuleCall_6_2_0 = (RuleCall)cSequenceAssignment_6_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		
		//Factor:
		//	{Factor} number=INT // should be unsigned
		//	| nodeName=ID | value=STRING | value="false" | value="true" | "(" expression=Expression ")" | op=OperatorName "("
		//	sequence=ExpressionSequence ")";
		public ParserRule getRule() { return rule; }

		//{Factor} number=INT // should be unsigned
		//| nodeName=ID | value=STRING | value="false" | value="true" | "(" expression=Expression ")" | op=OperatorName "("
		//sequence=ExpressionSequence ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Factor} number=INT
		public Group getGroup_0() { return cGroup_0; }

		//{Factor}
		public Action getFactorAction_0_0() { return cFactorAction_0_0; }

		//number=INT
		public Assignment getNumberAssignment_0_1() { return cNumberAssignment_0_1; }

		//INT
		public RuleCall getNumberINTTerminalRuleCall_0_1_0() { return cNumberINTTerminalRuleCall_0_1_0; }

		//nodeName=ID
		public Assignment getNodeNameAssignment_1() { return cNodeNameAssignment_1; }

		//ID
		public RuleCall getNodeNameIDTerminalRuleCall_1_0() { return cNodeNameIDTerminalRuleCall_1_0; }

		//value=STRING
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_0() { return cValueSTRINGTerminalRuleCall_2_0; }

		//value="false"
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//"false"
		public Keyword getValueFalseKeyword_3_0() { return cValueFalseKeyword_3_0; }

		//value="true"
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//"true"
		public Keyword getValueTrueKeyword_4_0() { return cValueTrueKeyword_4_0; }

		//"(" expression=Expression ")"
		public Group getGroup_5() { return cGroup_5; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_5_1() { return cExpressionAssignment_5_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_5_1_0() { return cExpressionExpressionParserRuleCall_5_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }

		//op=OperatorName "(" sequence=ExpressionSequence ")"
		public Group getGroup_6() { return cGroup_6; }

		//op=OperatorName
		public Assignment getOpAssignment_6_0() { return cOpAssignment_6_0; }

		//OperatorName
		public RuleCall getOpOperatorNameParserRuleCall_6_0_0() { return cOpOperatorNameParserRuleCall_6_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_6_1() { return cLeftParenthesisKeyword_6_1; }

		//sequence=ExpressionSequence
		public Assignment getSequenceAssignment_6_2() { return cSequenceAssignment_6_2; }

		//ExpressionSequence
		public RuleCall getSequenceExpressionSequenceParserRuleCall_6_2_0() { return cSequenceExpressionSequenceParserRuleCall_6_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6_3() { return cRightParenthesisKeyword_6_3; }
	}

	public class ExpressionSequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionSequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExpressionSequenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionsAssignment_1_1_1.eContents().get(0);
		
		//ExpressionSequence:
		//	{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?;
		public ParserRule getRule() { return rule; }

		//{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//{ExpressionSequence}
		public Action getExpressionSequenceAction_0() { return cExpressionSequenceAction_0; }

		//(expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0_0() { return cExpressionsExpressionParserRuleCall_1_0_0; }

		//("," expressions+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_1_1() { return cExpressionsAssignment_1_1_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_1_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLessThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLessThanSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignEqualsSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		//Comparison returns ecore::EString:
		//	"==" | "=" | "!=" | "<>" | "<" | "<=" | ">" | ">=";
		public ParserRule getRule() { return rule; }

		//"==" | "=" | "!=" | "<>" | "<" | "<=" | ">" | ">="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_0() { return cEqualsSignEqualsSignKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_2() { return cExclamationMarkEqualsSignKeyword_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_3() { return cLessThanSignGreaterThanSignKeyword_3; }

		//"<"
		public Keyword getLessThanSignKeyword_4() { return cLessThanSignKeyword_4; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_5() { return cLessThanSignEqualsSignKeyword_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_6() { return cGreaterThanSignKeyword_6; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_7() { return cGreaterThanSignEqualsSignKeyword_7; }
	}

	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusOrMinus");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//PlusOrMinus returns ecore::EString:
		//	"+" | "-";
		public ParserRule getRule() { return rule; }

		//"+" | "-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+"
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class TimesOrDivideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesOrDivide");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//TimesOrDivide returns ecore::EString:
		//	"*" | "/";
		public ParserRule getRule() { return rule; }

		//"*" | "/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }
	}

	public class OperatorNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperatorName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTruncateKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNormalKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLogNormalKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBetaKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGammaKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExponentialKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cWeibullKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cUniformKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cTriangularKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cPERTKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cBinomialKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cPoissonKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cNegativeBinomialKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cGeometricKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Keyword cDistributionKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final Keyword cNoisyORKeyword_14_1 = (Keyword)cGroup_14.eContents().get(1);
		private final Keyword cMinKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cMaxKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cLogKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cLog2Keyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLog10Keyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cExpKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cSinKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cCosKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cTanKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cSinhKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cCoshKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cTanhKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cSqrtKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cAbsKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cFloorKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cCeilKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cModKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Keyword cIfKeyword_32 = (Keyword)cAlternatives.eContents().get(32);
		private final Keyword cAndKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cOrKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cNotKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		
		/////////////////////////////////////////////////////	
		//// pending validations, for Java editor callbacks	
		/////////////////////////////////////////////////////
		//// TODO create a validation rule that states attribute is only allowed for discrete nodes
		//// TODO subtype attribute only for discrete (chance or decision) node
		//// TODO state_values attribute only for nodes of type number or interval
		//// TODO state_values attribute must appear after subtype and states attributes
		//// TODO state_values if subtype number list length same as states list
		//// TODO state_values if subtype interval list length one greater than states list
		//// TODO potential graph children must be >0 if parents used
		//// TODO chance, decision, and utility nodes can only have chance and decision nodes as parents
		//// TODO discrete nodes can only have discrete nodes as parents
		//// TODO a node must not be referenced in a potential specification before it has been defined by a node, decision, utility, or function specification
		//// TODO mean value of normal distribution must be linear function of continuous graph parents, each term must be numeric constant, name of continuous parent, or constant followed by '*' followed by name of continuous parent
		//// TODO formal input name must refer to a node listed in the inputs attribute of the class with name
		//// TODO the node referred to by the actual input name must be defined somewhere in the class containing the class instance
		//OperatorName returns ecore::EString:
		//	"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT"
		//	| "Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" "NoisyOR" | "min" | "max" | "log" |
		//	"log2" | "log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" |
		//	"mod" | "if" | "and" | "or" | "not";
		public ParserRule getRule() { return rule; }

		//"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT" |
		//"Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" "NoisyOR" | "min" | "max" | "log" | "log2" |
		//"log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" | "mod" | "if" |
		//"and" | "or" | "not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"truncate"
		public Keyword getTruncateKeyword_0() { return cTruncateKeyword_0; }

		//"Normal"
		public Keyword getNormalKeyword_1() { return cNormalKeyword_1; }

		//"LogNormal"
		public Keyword getLogNormalKeyword_2() { return cLogNormalKeyword_2; }

		//"Beta"
		public Keyword getBetaKeyword_3() { return cBetaKeyword_3; }

		//"Gamma"
		public Keyword getGammaKeyword_4() { return cGammaKeyword_4; }

		//"Exponential"
		public Keyword getExponentialKeyword_5() { return cExponentialKeyword_5; }

		//"Weibull"
		public Keyword getWeibullKeyword_6() { return cWeibullKeyword_6; }

		//"Uniform"
		public Keyword getUniformKeyword_7() { return cUniformKeyword_7; }

		//"Triangular"
		public Keyword getTriangularKeyword_8() { return cTriangularKeyword_8; }

		//"PERT"
		public Keyword getPERTKeyword_9() { return cPERTKeyword_9; }

		//"Binomial"
		public Keyword getBinomialKeyword_10() { return cBinomialKeyword_10; }

		//"Poisson"
		public Keyword getPoissonKeyword_11() { return cPoissonKeyword_11; }

		//"NegativeBinomial"
		public Keyword getNegativeBinomialKeyword_12() { return cNegativeBinomialKeyword_12; }

		//"Geometric"
		public Keyword getGeometricKeyword_13() { return cGeometricKeyword_13; }

		//"Distribution" "NoisyOR"
		public Group getGroup_14() { return cGroup_14; }

		//"Distribution"
		public Keyword getDistributionKeyword_14_0() { return cDistributionKeyword_14_0; }

		//"NoisyOR"
		public Keyword getNoisyORKeyword_14_1() { return cNoisyORKeyword_14_1; }

		//"min"
		public Keyword getMinKeyword_15() { return cMinKeyword_15; }

		//"max"
		public Keyword getMaxKeyword_16() { return cMaxKeyword_16; }

		//"log"
		public Keyword getLogKeyword_17() { return cLogKeyword_17; }

		//"log2"
		public Keyword getLog2Keyword_18() { return cLog2Keyword_18; }

		//"log10"
		public Keyword getLog10Keyword_19() { return cLog10Keyword_19; }

		//"exp"
		public Keyword getExpKeyword_20() { return cExpKeyword_20; }

		//"sin"
		public Keyword getSinKeyword_21() { return cSinKeyword_21; }

		//"cos"
		public Keyword getCosKeyword_22() { return cCosKeyword_22; }

		//"tan"
		public Keyword getTanKeyword_23() { return cTanKeyword_23; }

		//"sinh"
		public Keyword getSinhKeyword_24() { return cSinhKeyword_24; }

		//"cosh"
		public Keyword getCoshKeyword_25() { return cCoshKeyword_25; }

		//"tanh"
		public Keyword getTanhKeyword_26() { return cTanhKeyword_26; }

		//"sqrt"
		public Keyword getSqrtKeyword_27() { return cSqrtKeyword_27; }

		//"abs"
		public Keyword getAbsKeyword_28() { return cAbsKeyword_28; }

		//"floor"
		public Keyword getFloorKeyword_29() { return cFloorKeyword_29; }

		//"ceil"
		public Keyword getCeilKeyword_30() { return cCeilKeyword_30; }

		//"mod"
		public Keyword getModKeyword_31() { return cModKeyword_31; }

		//"if"
		public Keyword getIfKeyword_32() { return cIfKeyword_32; }

		//"and"
		public Keyword getAndKeyword_33() { return cAndKeyword_33; }

		//"or"
		public Keyword getOrKeyword_34() { return cOrKeyword_34; }

		//"not"
		public Keyword getNotKeyword_35() { return cNotKeyword_35; }
	}
	
	
	private ModelElements pModel;
	private SignElements pSign;
	private FloatElements pFloat;
	private TerminalRule tSL_COMMENT;
	private DomainDefinitionElements pDomainDefinition;
	private DomainHeaderElements pDomainHeader;
	private DomainElementElements pDomainElement;
	private AttributeElements pAttribute;
	private BasicNodeElements pBasicNode;
	private BasicNodeKeywordElements pBasicNodeKeyword;
	private StatesAttributeElements pStatesAttribute;
	private LabelAttributeElements pLabelAttribute;
	private PositionAttributeElements pPositionAttribute;
	private SubtypeAttributeElements pSubtypeAttribute;
	private StateValuesAttributeElements pStateValuesAttribute;
	private ApplicationAttributeElements pApplicationAttribute;
	private NodeSizeAttributeElements pNodeSizeAttribute;
	private PotentialElements pPotential;
	private PotentialGraphElements pPotentialGraph;
	private PotentialModelElements pPotentialModel;
	private PotentialAttributeElements pPotentialAttribute;
	private PotentialDataAttributeElements pPotentialDataAttribute;
	private UnstructuredDataListElements pUnstructuredDataList;
	private StructuredDataListElements pStructuredDataList;
	private FloatDataListElements pFloatDataList;
	private NormalDistributionElements pNormalDistribution;
	private MeanExpressionElements pMeanExpression;
	private MeanTermElements pMeanTerm;
	private PotentialTableAttributeElements pPotentialTableAttribute;
	private ModelNodesAttributeElements pModelNodesAttribute;
	private SamplesAttributeElements pSamplesAttribute;
	private ModelDataAttributeElements pModelDataAttribute;
	private ClassDefinitionElements pClassDefinition;
	private ClassElementElements pClassElement;
	private ClassInstanceElements pClassInstance;
	private InputBindingsElements pInputBindings;
	private InputBindingElements pInputBinding;
	private OutputBindingsElements pOutputBindings;
	private OutputBindingElements pOutputBinding;
	private NodeAttributesElements pNodeAttributes;
	private ExpressionElements pExpression;
	private SimpleExpressionElements pSimpleExpression;
	private TermElements pTerm;
	private ExpFactorElements pExpFactor;
	private FactorElements pFactor;
	private ExpressionSequenceElements pExpressionSequence;
	private ComparisonElements pComparison;
	private PlusOrMinusElements pPlusOrMinus;
	private TimesOrDivideElements pTimesOrDivide;
	private OperatorNameElements pOperatorName;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public NetDSLGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	domain=DomainDefinition?;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Sign returns ecore::EString hidden():
	//	"+" | "-";
	public SignElements getSignAccess() {
		return (pSign != null) ? pSign : (pSign = new SignElements());
	}
	
	public ParserRule getSignRule() {
		return getSignAccess().getRule();
	}

	//Float returns ecore::EString:
	//	Sign? INT ("." INT)?;
	public FloatElements getFloatAccess() {
		return (pFloat != null) ? pFloat : (pFloat = new FloatElements());
	}
	
	public ParserRule getFloatRule() {
		return getFloatAccess().getRule();
	}

	//// UnsignedNumber returns ecore::EString hidden(): INT ('.' INT)? ;
	//// single-line comment style leading with %
	//// the built-in version allows // as indicator, overridden here
	//// multi-line comments are also built-in but should be overridden
	//terminal SL_COMMENT:
	//	"%" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//DomainDefinition:
	//	header=DomainHeader elements+=DomainElement*;
	public DomainDefinitionElements getDomainDefinitionAccess() {
		return (pDomainDefinition != null) ? pDomainDefinition : (pDomainDefinition = new DomainDefinitionElements());
	}
	
	public ParserRule getDomainDefinitionRule() {
		return getDomainDefinitionAccess().getRule();
	}

	//DomainHeader:
	//	{DomainHeader} "net" "{" attributes+=Attribute* "}";
	public DomainHeaderElements getDomainHeaderAccess() {
		return (pDomainHeader != null) ? pDomainHeader : (pDomainHeader = new DomainHeaderElements());
	}
	
	public ParserRule getDomainHeaderRule() {
		return getDomainHeaderAccess().getRule();
	}

	//DomainElement:
	//	BasicNode | Potential | ClassDefinition;
	public DomainElementElements getDomainElementAccess() {
		return (pDomainElement != null) ? pDomainElement : (pDomainElement = new DomainElementElements());
	}
	
	public ParserRule getDomainElementRule() {
		return getDomainElementAccess().getRule();
	}

	//Attribute:
	//	StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute
	//	| NodeSizeAttribute;
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//BasicNode:
	//	keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}";
	public BasicNodeElements getBasicNodeAccess() {
		return (pBasicNode != null) ? pBasicNode : (pBasicNode = new BasicNodeElements());
	}
	
	public ParserRule getBasicNodeRule() {
		return getBasicNodeAccess().getRule();
	}

	//BasicNodeKeyword returns ecore::EString:
	//	("discrete" | "continuous")? "node" | "decision" | "utility" | "function";
	public BasicNodeKeywordElements getBasicNodeKeywordAccess() {
		return (pBasicNodeKeyword != null) ? pBasicNodeKeyword : (pBasicNodeKeyword = new BasicNodeKeywordElements());
	}
	
	public ParserRule getBasicNodeKeywordRule() {
		return getBasicNodeKeywordAccess().getRule();
	}

	//StatesAttribute:
	//	{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";";
	public StatesAttributeElements getStatesAttributeAccess() {
		return (pStatesAttribute != null) ? pStatesAttribute : (pStatesAttribute = new StatesAttributeElements());
	}
	
	public ParserRule getStatesAttributeRule() {
		return getStatesAttributeAccess().getRule();
	}

	//LabelAttribute:
	//	"label" "=" value=STRING ";";
	public LabelAttributeElements getLabelAttributeAccess() {
		return (pLabelAttribute != null) ? pLabelAttribute : (pLabelAttribute = new LabelAttributeElements());
	}
	
	public ParserRule getLabelAttributeRule() {
		return getLabelAttributeAccess().getRule();
	}

	//PositionAttribute:
	//	"position" "=" "(" x=INT y=INT ")" ";";
	public PositionAttributeElements getPositionAttributeAccess() {
		return (pPositionAttribute != null) ? pPositionAttribute : (pPositionAttribute = new PositionAttributeElements());
	}
	
	public ParserRule getPositionAttributeRule() {
		return getPositionAttributeAccess().getRule();
	}

	//SubtypeAttribute:
	//	"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";";
	public SubtypeAttributeElements getSubtypeAttributeAccess() {
		return (pSubtypeAttribute != null) ? pSubtypeAttribute : (pSubtypeAttribute = new SubtypeAttributeElements());
	}
	
	public ParserRule getSubtypeAttributeRule() {
		return getSubtypeAttributeAccess().getRule();
	}

	//StateValuesAttribute:
	//	"state_values" "=" "(" numbers+=INT+ ")" ";";
	public StateValuesAttributeElements getStateValuesAttributeAccess() {
		return (pStateValuesAttribute != null) ? pStateValuesAttribute : (pStateValuesAttribute = new StateValuesAttributeElements());
	}
	
	public ParserRule getStateValuesAttributeRule() {
		return getStateValuesAttributeAccess().getRule();
	}

	//ApplicationAttribute:
	//	key=ID "=" value=STRING ";";
	public ApplicationAttributeElements getApplicationAttributeAccess() {
		return (pApplicationAttribute != null) ? pApplicationAttribute : (pApplicationAttribute = new ApplicationAttributeElements());
	}
	
	public ParserRule getApplicationAttributeRule() {
		return getApplicationAttributeAccess().getRule();
	}

	//// global magic for HUGIN GUI
	//NodeSizeAttribute:
	//	"node_size" "=" "(" width=INT height=INT ")" ";";
	public NodeSizeAttributeElements getNodeSizeAttributeAccess() {
		return (pNodeSizeAttribute != null) ? pNodeSizeAttribute : (pNodeSizeAttribute = new NodeSizeAttributeElements());
	}
	
	public ParserRule getNodeSizeAttributeRule() {
		return getNodeSizeAttributeAccess().getRule();
	}

	//Potential:
	//	"potential" graph=PotentialGraph model=PotentialModel;
	public PotentialElements getPotentialAccess() {
		return (pPotential != null) ? pPotential : (pPotential = new PotentialElements());
	}
	
	public ParserRule getPotentialRule() {
		return getPotentialAccess().getRule();
	}

	//PotentialGraph:
	//	{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")";
	public PotentialGraphElements getPotentialGraphAccess() {
		return (pPotentialGraph != null) ? pPotentialGraph : (pPotentialGraph = new PotentialGraphElements());
	}
	
	public ParserRule getPotentialGraphRule() {
		return getPotentialGraphAccess().getRule();
	}

	//PotentialModel:
	//	{PotentialModel} "{" attributes+=PotentialAttribute* "}";
	public PotentialModelElements getPotentialModelAccess() {
		return (pPotentialModel != null) ? pPotentialModel : (pPotentialModel = new PotentialModelElements());
	}
	
	public ParserRule getPotentialModelRule() {
		return getPotentialModelAccess().getRule();
	}

	//PotentialAttribute:
	//	PotentialDataAttribute | PotentialTableAttribute;
	public PotentialAttributeElements getPotentialAttributeAccess() {
		return (pPotentialAttribute != null) ? pPotentialAttribute : (pPotentialAttribute = new PotentialAttributeElements());
	}
	
	public ParserRule getPotentialAttributeRule() {
		return getPotentialAttributeAccess().getRule();
	}

	//PotentialDataAttribute:
	//	{PotentialDataAttribute} "data" "=" "(" (unstructured=UnstructuredDataList | items+=StructuredDataList*) ")" ";";
	public PotentialDataAttributeElements getPotentialDataAttributeAccess() {
		return (pPotentialDataAttribute != null) ? pPotentialDataAttribute : (pPotentialDataAttribute = new PotentialDataAttributeElements());
	}
	
	public ParserRule getPotentialDataAttributeRule() {
		return getPotentialDataAttributeAccess().getRule();
	}

	//UnstructuredDataList:
	//	{UnstructuredDataList} list=FloatDataList | normal=NormalDistribution;
	public UnstructuredDataListElements getUnstructuredDataListAccess() {
		return (pUnstructuredDataList != null) ? pUnstructuredDataList : (pUnstructuredDataList = new UnstructuredDataListElements());
	}
	
	public ParserRule getUnstructuredDataListRule() {
		return getUnstructuredDataListAccess().getRule();
	}

	//StructuredDataList:
	//	{StructuredDataList} "(" (list=FloatDataList | items+=StructuredDataList*) ")";
	public StructuredDataListElements getStructuredDataListAccess() {
		return (pStructuredDataList != null) ? pStructuredDataList : (pStructuredDataList = new StructuredDataListElements());
	}
	
	public ParserRule getStructuredDataListRule() {
		return getStructuredDataListAccess().getRule();
	}

	//FloatDataList:
	//	{FloatDataList} items+=Float*;
	public FloatDataListElements getFloatDataListAccess() {
		return (pFloatDataList != null) ? pFloatDataList : (pFloatDataList = new FloatDataListElements());
	}
	
	public ParserRule getFloatDataListRule() {
		return getFloatDataListAccess().getRule();
	}

	//NormalDistribution:
	//	"normal" "(" mean=MeanExpression "," variance=Float ")";
	public NormalDistributionElements getNormalDistributionAccess() {
		return (pNormalDistribution != null) ? pNormalDistribution : (pNormalDistribution = new NormalDistributionElements());
	}
	
	public ParserRule getNormalDistributionRule() {
		return getNormalDistributionAccess().getRule();
	}

	//MeanExpression returns ecore::EString:
	//	MeanTerm ("+" MeanTerm)*;
	public MeanExpressionElements getMeanExpressionAccess() {
		return (pMeanExpression != null) ? pMeanExpression : (pMeanExpression = new MeanExpressionElements());
	}
	
	public ParserRule getMeanExpressionRule() {
		return getMeanExpressionAccess().getRule();
	}

	//MeanTerm returns ecore::EString:
	//	Float | Float "*" ID | ID;
	public MeanTermElements getMeanTermAccess() {
		return (pMeanTerm != null) ? pMeanTerm : (pMeanTerm = new MeanTermElements());
	}
	
	public ParserRule getMeanTermRule() {
		return getMeanTermAccess().getRule();
	}

	//PotentialTableAttribute:
	//	nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute;
	public PotentialTableAttributeElements getPotentialTableAttributeAccess() {
		return (pPotentialTableAttribute != null) ? pPotentialTableAttribute : (pPotentialTableAttribute = new PotentialTableAttributeElements());
	}
	
	public ParserRule getPotentialTableAttributeRule() {
		return getPotentialTableAttributeAccess().getRule();
	}

	//ModelNodesAttribute:
	//	{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";";
	public ModelNodesAttributeElements getModelNodesAttributeAccess() {
		return (pModelNodesAttribute != null) ? pModelNodesAttribute : (pModelNodesAttribute = new ModelNodesAttributeElements());
	}
	
	public ParserRule getModelNodesAttributeRule() {
		return getModelNodesAttributeAccess().getRule();
	}

	//SamplesAttribute:
	//	"samples_per_interval" "=" value=INT ";";
	public SamplesAttributeElements getSamplesAttributeAccess() {
		return (pSamplesAttribute != null) ? pSamplesAttribute : (pSamplesAttribute = new SamplesAttributeElements());
	}
	
	public ParserRule getSamplesAttributeRule() {
		return getSamplesAttributeAccess().getRule();
	}

	//ModelDataAttribute:
	//	{ModelDataAttribute} "model_data" "=" "(" ")" // TODO add expression sequence, introduces left recursion
	//	";";
	public ModelDataAttributeElements getModelDataAttributeAccess() {
		return (pModelDataAttribute != null) ? pModelDataAttribute : (pModelDataAttribute = new ModelDataAttributeElements());
	}
	
	public ParserRule getModelDataAttributeRule() {
		return getModelDataAttributeAccess().getRule();
	}

	/////////////////////////////////////////////////////
	//// classes
	/////////////////////////////////////////////////////
	//ClassDefinition:
	//	"class" name=ID "{" elements+=ClassElement* "}";
	public ClassDefinitionElements getClassDefinitionAccess() {
		return (pClassDefinition != null) ? pClassDefinition : (pClassDefinition = new ClassDefinitionElements());
	}
	
	public ParserRule getClassDefinitionRule() {
		return getClassDefinitionAccess().getRule();
	}

	//ClassElement:
	//	DomainElement | Attribute | ClassInstance;
	public ClassElementElements getClassElementAccess() {
		return (pClassElement != null) ? pClassElement : (pClassElement = new ClassElementElements());
	}
	
	public ParserRule getClassElementRule() {
		return getClassElementAccess().getRule();
	}

	//ClassInstance:
	//	"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
	//	attributes=NodeAttributes "}";
	public ClassInstanceElements getClassInstanceAccess() {
		return (pClassInstance != null) ? pClassInstance : (pClassInstance = new ClassInstanceElements());
	}
	
	public ParserRule getClassInstanceRule() {
		return getClassInstanceAccess().getRule();
	}

	//InputBindings:
	//	lhs=InputBinding "," rhs=InputBindings;
	public InputBindingsElements getInputBindingsAccess() {
		return (pInputBindings != null) ? pInputBindings : (pInputBindings = new InputBindingsElements());
	}
	
	public ParserRule getInputBindingsRule() {
		return getInputBindingsAccess().getRule();
	}

	//InputBinding:
	//	formal=ID "=" actual=ID;
	public InputBindingElements getInputBindingAccess() {
		return (pInputBinding != null) ? pInputBinding : (pInputBinding = new InputBindingElements());
	}
	
	public ParserRule getInputBindingRule() {
		return getInputBindingAccess().getRule();
	}

	//OutputBindings:
	//	lhs=OutputBinding "," rhs=OutputBindings;
	public OutputBindingsElements getOutputBindingsAccess() {
		return (pOutputBindings != null) ? pOutputBindings : (pOutputBindings = new OutputBindingsElements());
	}
	
	public ParserRule getOutputBindingsRule() {
		return getOutputBindingsAccess().getRule();
	}

	//OutputBinding:
	//	actual=ID "=" formal=ID;
	public OutputBindingElements getOutputBindingAccess() {
		return (pOutputBinding != null) ? pOutputBinding : (pOutputBinding = new OutputBindingElements());
	}
	
	public ParserRule getOutputBindingRule() {
		return getOutputBindingAccess().getRule();
	}

	//NodeAttributes:
	//	LabelAttribute | PositionAttribute | ApplicationAttribute;
	public NodeAttributesElements getNodeAttributesAccess() {
		return (pNodeAttributes != null) ? pNodeAttributes : (pNodeAttributes = new NodeAttributesElements());
	}
	
	public ParserRule getNodeAttributesRule() {
		return getNodeAttributesAccess().getRule();
	}

	/////////////////////////////////////////////////////
	//// expressions
	/////////////////////////////////////////////////////
	//// simple=SimpleExpression
	//Expression:
	//	lhs=SimpleExpression (Comparison rhs+=SimpleExpression)* // |
	//;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// PlusOrMinus single=Term // |
	//// lhs=Term
	//SimpleExpression:
	//	lhs=Term (PlusOrMinus rhs+=SimpleExpression)* // | // was swapped
	//;
	public SimpleExpressionElements getSimpleExpressionAccess() {
		return (pSimpleExpression != null) ? pSimpleExpression : (pSimpleExpression = new SimpleExpressionElements());
	}
	
	public ParserRule getSimpleExpressionRule() {
		return getSimpleExpressionAccess().getRule();
	}

	//// lhs=ExpFactor
	//Term:
	//	lhs=ExpFactor (TimesOrDivide rhs+=Term)* // |
	//;
	public TermElements getTermAccess() {
		return (pTerm != null) ? pTerm : (pTerm = new TermElements());
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//// factor=Factor
	//ExpFactor:
	//	lhs=Factor ("^" rhs+=ExpFactor)* // |
	//;
	public ExpFactorElements getExpFactorAccess() {
		return (pExpFactor != null) ? pExpFactor : (pExpFactor = new ExpFactorElements());
	}
	
	public ParserRule getExpFactorRule() {
		return getExpFactorAccess().getRule();
	}

	//Factor:
	//	{Factor} number=INT // should be unsigned
	//	| nodeName=ID | value=STRING | value="false" | value="true" | "(" expression=Expression ")" | op=OperatorName "("
	//	sequence=ExpressionSequence ")";
	public FactorElements getFactorAccess() {
		return (pFactor != null) ? pFactor : (pFactor = new FactorElements());
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}

	//ExpressionSequence:
	//	{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?;
	public ExpressionSequenceElements getExpressionSequenceAccess() {
		return (pExpressionSequence != null) ? pExpressionSequence : (pExpressionSequence = new ExpressionSequenceElements());
	}
	
	public ParserRule getExpressionSequenceRule() {
		return getExpressionSequenceAccess().getRule();
	}

	//Comparison returns ecore::EString:
	//	"==" | "=" | "!=" | "<>" | "<" | "<=" | ">" | ">=";
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//PlusOrMinus returns ecore::EString:
	//	"+" | "-";
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return (pPlusOrMinus != null) ? pPlusOrMinus : (pPlusOrMinus = new PlusOrMinusElements());
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}

	//TimesOrDivide returns ecore::EString:
	//	"*" | "/";
	public TimesOrDivideElements getTimesOrDivideAccess() {
		return (pTimesOrDivide != null) ? pTimesOrDivide : (pTimesOrDivide = new TimesOrDivideElements());
	}
	
	public ParserRule getTimesOrDivideRule() {
		return getTimesOrDivideAccess().getRule();
	}

	/////////////////////////////////////////////////////	
	//// pending validations, for Java editor callbacks	
	/////////////////////////////////////////////////////
	//// TODO create a validation rule that states attribute is only allowed for discrete nodes
	//// TODO subtype attribute only for discrete (chance or decision) node
	//// TODO state_values attribute only for nodes of type number or interval
	//// TODO state_values attribute must appear after subtype and states attributes
	//// TODO state_values if subtype number list length same as states list
	//// TODO state_values if subtype interval list length one greater than states list
	//// TODO potential graph children must be >0 if parents used
	//// TODO chance, decision, and utility nodes can only have chance and decision nodes as parents
	//// TODO discrete nodes can only have discrete nodes as parents
	//// TODO a node must not be referenced in a potential specification before it has been defined by a node, decision, utility, or function specification
	//// TODO mean value of normal distribution must be linear function of continuous graph parents, each term must be numeric constant, name of continuous parent, or constant followed by '*' followed by name of continuous parent
	//// TODO formal input name must refer to a node listed in the inputs attribute of the class with name
	//// TODO the node referred to by the actual input name must be defined somewhere in the class containing the class instance
	//OperatorName returns ecore::EString:
	//	"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT"
	//	| "Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" "NoisyOR" | "min" | "max" | "log" |
	//	"log2" | "log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" |
	//	"mod" | "if" | "and" | "or" | "not";
	public OperatorNameElements getOperatorNameAccess() {
		return (pOperatorName != null) ? pOperatorName : (pOperatorName = new OperatorNameElements());
	}
	
	public ParserRule getOperatorNameRule() {
		return getOperatorNameAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" | "n" |
	//	"f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
